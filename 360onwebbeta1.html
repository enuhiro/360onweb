<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  />
  <title>360onWeb + Crop</title>
  <style>
    :root {
      --bg-gradient-start: #1e3c72;
      --bg-gradient-end: #2a5298;
      --slider-grdnt-start: #4caf50;
      --slider-grdnt-end: #2196f3;
      --upload-area-border--: 3px dashed #4caf50;
      --upload-area-bg--: rgba(255, 255, 255, 0.1);
      --upload-hover-border--: #45a049;
      --upload-hover-bg--: rgba(255, 255, 255, 0.15);
      --upload-dragover-border--: #2196f3;
      --upload-dragover-bg--: rgba(33, 150, 243, 0.2);
      --upload-btn--: #4caf50;
      --upload-btn-hover--: #45a049;
      --random-btn--: #ff6b6b;
      --download-btn-bg--: linear-gradient(45deg, #667eea, #764ba2);
      --download-btn-hover--: rgba(0, 0, 0, 0.3);
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(
        135deg,
        var(--bg-gradient-start),
        var(--bg-gradient-end)
      );
      color: white;
      min-height: 100vh;
    }

    .container {
      max-width: 1524px;
      margin: 0 auto;
    }

    .upload-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      flex-wrap: nowrap;
    }

    .upload-area {
      border: var(--upload-area-border--);
      border-radius: 10px;
      padding: 20px;
      text-align: center;
      margin-bottom: 20px;
      background: var(--upload-area-bg--);
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .upload-area:hover {
      border-color: var(--upload-hover-border--);
      background: var(--upload-hover-bg--);
    }

    .upload-area.dragover {
      border-color: var(--upload-dragover-border--);
      background: var(--upload-dragover-bg--);
    }

    input[type='file'] {
      display: none;
    }

    .upload-btn {
      background: var(--upload-btn--);
      color: white;
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.3s;
      white-space: nowrap;
    }

    .upload-btn:hover {
      background: var(--upload-btn-hover--);
    }

    .random-btn {
      width: 48px;
      height: 48px;
      background: transparent;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 28px;
      transition: all 0.3s ease;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .random-btn:hover {
      transform: scale(1.1);
    }

    .guideline-select {
      padding: 8px 12px;
      border-radius: 5px;
      border: none;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.3s;
      min-width: 140px;
      flex-shrink: 0;
    }
    .guideline-select:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .main-content {
      display: none;
    }

    .editor-container {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      flex-direction: row;
    }

    .canvas-container {
      flex: 1;
      text-align: center;
      position: relative;
    }

    .canvas-wrapper {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    canvas {
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      max-width: 100%;
      height: auto;
      touch-action: none;
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }

    .guideline-rotate-btn {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.3);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 18px;
      cursor: pointer;
      z-index: 15;
      transition: background 0.3s;
      display: none;
    }
    .guideline-rotate-btn:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    .touch-indicator {
      position: absolute;
      top: 10px;
      left: 60px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      display: none;
      z-index: 12;
    }

    .controls {
      width: 340px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .control-group {
      margin-bottom: 16px;
    }

    .control-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      font-weight: 600;
      color: #f0f0f0;
      gap: 10px;
      flex-wrap: wrap;
    }

    .value-display {
      font-size: 13px;
      color: #ddd;
      text-align: right;
      min-width: 70px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      padding: 2px 6px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .value-display:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
    }

    .value-input {
      font-size: 13px;
      color: white;
      text-align: right;
      min-width: 70px;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid #4caf50;
      border-radius: 4px;
      padding: 2px 6px;
      outline: none;
      display: none;
    }

    .slider-container {
      position: relative;
    }

    input[type='range'] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: linear-gradient(
        90deg,
        var(--slider-grdnt-start),
        var(--slider-grdnt-end)
      );
      outline: none;
      -webkit-appearance: none;
    }

    input[type='range']::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    input[type='range']::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .download-btn {
      width: 100%;
      background: var(--download-btn-bg--);
      color: white;
      border: none;
      padding: 12px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      margin-top: 6px;
      transition: all 0.3s ease;
    }
    .download-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px var(--download-btn-hover--);
    }

    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    .loading-content {
      text-align: center;
      color: white;
      font-size: 18px;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @media (max-width: 1024px) {
      .editor-container { flex-direction: column; }
      .controls { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="upload-area" id="uploadArea">
      <div class="upload-header">
        <button class="upload-btn" onclick="resetControlsAndSelectFile()">üñºÔ∏è+360onWeb</button>
        <select id="guidelineSelect" class="guideline-select">
          <option value="none">„Ç¨„Ç§„Éâ„Å™„Åó(1„Äú16)</option>
          <option value="line01">1.ÂêåÂøÉÂÜÜ</option>
          <option value="line02">2.‰∏âÈáçÂÜÜ</option>
          <option value="line03">3.ÂÜÜÂàÜÂâ≤</option>
          <option value="line04">4.„Åó„Åº„Çä</option>
          <option value="line05">5.Ê∏¶Â∑ª„Åç</option>
          <option value="line06">6.‰∏âÂàÜÂâ≤</option>
          <option value="line07">7.ÂõõÂàÜÂâ≤</option>
          <option value="line08">8.ÊîæÂ∞ÑÂàÜÂâ≤</option>
          <option value="line09">9.Êñú„ÇÅÂàÜÂâ≤</option>
          <option value="line10">10.ÈÅ†ËøëÊñú„ÇÅ</option>
          <option value="line11">11.ÈÅ†ËøëÊ∞¥Âπ≥</option>
          <option value="line12">12.„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅ</option>
          <option value="line13">13.SÂ≠ó</option>
          <option value="line14">14.UÂ≠ó</option>
          <option value="line15">15.‰∫å„Å§Á™ì</option>
          <option value="line16">16.ÈõªÂΩ±„ÇØ„É≠„Çπ„Ç≤„Éº„Ç∏</option>
        </select>
        <button class="random-btn" id="randomBtn">ü§Ø</button>
      </div>
      <input type="file" id="fileInput" accept="image/*" />
    </div>

    <div class="main-content" id="mainContent">
      <div class="editor-container">
        <div class="canvas-container">
          <div class="canvas-wrapper">
            <canvas id="canvas" width="720" height="720"></canvas>
            <button id="guidelineRotateBtn" class="guideline-rotate-btn">üîÑ</button>
            <div class="touch-indicator" id="touchIndicator">Move Center</div>
          </div>
        </div>

        <div class="controls">
          <!-- Sliders -->
          <div class="control-group">
            <div class="control-label">
              <span class="label-text">üîç Zoom Êã°Â§ßÁ∏ÆÂ∞è</span>
              <input type="text" class="value-input" id="scaleInput" value="1.5" />
              <span class="value-display" id="scaleValue">1.50</span>
            </div>
            <div class="slider-container">
              <input type="range" id="scaleSlider" min="0.1" max="2.9" step="0.1" value="1.5" />
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">
              <span class="label-text">‚ö° V-Flex Á∏¶-‰º∏Á∏Æ</span>
              <input type="text" class="value-input" id="exponentialInput" value="0.0" />
              <span class="value-display" id="exponentialValue">0.00</span>
            </div>
            <div class="slider-container">
              <input type="range" id="exponentialSlider" min="-1.0" max="1.0" step="0.01" value="0" />
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">
              <span class="label-text">üåÄ Twister Á´úÂ∑ª</span>
              <input type="text" class="value-input" id="swirlInput" value="0.0" />
              <span class="value-display" id="swirlValue">0.00</span>
            </div>
            <div class="slider-container">
              <input type="range" id="swirlSlider" min="-2.0" max="2.0" step="0.1" value="0" />
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">
              <span class="label-text">‚ÜïÔ∏è Up Down ‰∏ä‰∏ã</span>
              <input type="text" class="value-input" id="pitchInput" value="0¬∞" />
              <span class="value-display" id="pitchValue">0.00¬∞</span>
            </div>
            <div class="slider-container">
              <input type="range" id="pitchSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1)" />
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">
              <span class="label-text">‚ÜîÔ∏è Left Right Â∑¶Âè≥</span>
              <input type="text" class="value-input" id="rollInput" value="0¬∞" />
              <span class="value-display" id="rollValue">0.00¬∞</span>
            </div>
            <div class="slider-container">
              <input type="range" id="rollSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1)" />
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">
              <span class="label-text">üîÑ Rotate ÂõûËª¢</span>
              <input type="text" class="value-input" id="yawInput" value="0¬∞" />
              <span class="value-display" id="yawValue">0.00¬∞</span>
            </div>
            <div class="slider-container">
              <input type="range" id="yawSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1)" />
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">
              <span class="label-text">XY-rotate</span>
              <input type="text" class="value-input" id="imgRotateInput" value="0¬∞" />
              <span class="value-display" id="imgRotateValue">0.00¬∞</span>
            </div>
            <div class="slider-container">
              <input type="range" id="imgRotateSlider" min="-180" max="180" step="1" value="0" />
            </div>
          </div>

          <div class="control-group" id="centerXGroup" style="display:none">
            <div class="control-label">
              <span class="label-text">X-shift</span>
              <input type="text" class="value-input" id="centerXInput" value="0.00" />
              <span class="value-display" id="centerXValue">0.00</span>
            </div>
            <div class="slider-container">
              <input type="range" id="centerXSlider" min="-1" max="1" step="0.01" value="0" style="transform: scaleX(-1)" />
            </div>
          </div>

          <div class="control-group" id="centerYGroup" style="display:none">
            <div class="control-label">
              <span class="label-text">Y-shift</span>
              <input type="text" class="value-input" id="centerYInput" value="0.00" />
              <span class="value-display" id="centerYValue">0.00</span>
            </div>
            <div class="slider-container">
              <input type="range" id="centerYSlider" min="-1" max="1" step="0.01" value="0" style="transform: scaleX(-1)" />
            </div>
          </div>

          <!-- Menus -->
          <div class="control-group" style="display:flex; gap:10px; align-items:center;">
            <label for="editModeSelect" style="min-width:120px">üéö Edit type</label>
            <select id="editModeSelect" class="guideline-select" style="flex:1">
              <option value="little_planet">Little Planet</option>
              <option value="rabbit_hole">Rabbit Hole</option>
            </select>
          </div>

          <div class="control-group" style="display:flex; gap:10px; align-items:center;">
            <label for="formatSelect" style="min-width:120px">üé® Format type</label>
            <select id="formatSelect" class="guideline-select" style="flex:1">
              <option value="jpeg">JPG 80%</option>
              <option value="png">PNG</option>
            </select>
          </div>

          <div class="control-group" style="display:flex; gap:10px; align-items:center;">
            <label for="resolutionSelect" style="min-width:120px">üìê Pixel size</label>
            <select id="resolutionSelect" class="guideline-select" style="flex:1">
              <option value="512">512√ó512 (Preview)</option>
              <option value="2048">2048√ó2048 (2K)</option>
              <option value="4096">4096√ó4096 (4K)</option>
            </select>
          </div>

          <!-- ‚úÇÔ∏è Crop UI -->
          <div class="control-group">
            <div class="control-label">
              <span class="label-text">‚úÇÔ∏è Crop „Éà„É™„Éü„É≥„Ç∞</span>
              <span class="value-display" id="cropModeValue">OFF</span>
            </div>
            <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
              <button id="cropToggleBtn" class="upload-btn" type="button">Crop: OFF</button>
              <select id="cropAspectSelect" class="guideline-select">
                <option value="free">Free</option>
                <option value="1:1">1:1</option>
                <option value="4:3">4:3</option>
                <option value="3:2">3:2</option>
                <option value="16:9">16:9</option>
                <option value="9:16">9:16</option>
              </select>
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">
              <span class="label-text">üß≠ Crop Size</span>
              <span class="value-display" id="cropSizeValue">0.60</span>
            </div>
            <div class="slider-container">
              <input type="range" id="cropSizeSlider" min="0.1" max="1.0" step="0.01" value="0.6" />
            </div>
          </div>

          <div class="control-group" style="display:flex; gap:8px; flex-wrap:wrap;">
            <button class="download-btn" id="cropDownloadBtn" type="button">‚¨áÔ∏è Save Cropped</button>
          </div>

          <!-- Download -->
          <button class="download-btn" id="downloadBtn">üìÇ Download</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Loading overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-content">
      <div class="spinner"></div>
      <div id="loadingText">Processing image...</div>
    </div>
  </div>

  <script>
    // ====== State images ======
    let originalImage = null;
    let workingImage = null;   // 1024x512
    let downloadImage = null;  // 4096x2048
    let isLittlePlanet = true;

    // ====== Guideline ======
    let guidelineImages = {};
    const guidelineTypes = ['line01','line02','line03','line04','line05','line06','line07','line08','line09','line10','line11','line12','line13','line14','line15','line16'];
    let guidelineRotation = 0;

    // ====== Canvas & UI ======
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const fileInput = document.getElementById('fileInput');
    const uploadArea = document.getElementById('uploadArea');
    const mainContent = document.getElementById('mainContent');
    const touchIndicator = document.getElementById('touchIndicator');

    const scaleSlider = document.getElementById('scaleSlider');
    const exponentialSlider = document.getElementById('exponentialSlider');
    const pitchSlider = document.getElementById('pitchSlider');
    const rollSlider = document.getElementById('rollSlider');
    const yawSlider = document.getElementById('yawSlider');
    const imgRotateSlider = document.getElementById('imgRotateSlider');
    const editModeSelect = document.getElementById('editModeSelect');
    const resolutionSelect = document.getElementById('resolutionSelect');
    const formatSelect = document.getElementById('formatSelect');

    const scaleValue = document.getElementById('scaleValue');
    const exponentialValue = document.getElementById('exponentialValue');
    const pitchValue = document.getElementById('pitchValue');
    const rollValue = document.getElementById('rollValue');
    const yawValue = document.getElementById('yawValue');
    const imgRotateValue = document.getElementById('imgRotateValue');

    const scaleInput = document.getElementById('scaleInput');
    const exponentialInput = document.getElementById('exponentialInput');
    const pitchInput = document.getElementById('pitchInput');
    const rollInput = document.getElementById('rollInput');
    const yawInput = document.getElementById('yawInput');
    const imgRotateInput = document.getElementById('imgRotateInput');

    const centerXSlider = document.getElementById('centerXSlider');
    const centerYSlider = document.getElementById('centerYSlider');
    const centerXValue = document.getElementById('centerXValue');
    const centerYValue = document.getElementById('centerYValue');
    const centerXInput = document.getElementById('centerXInput');
    const centerYInput = document.getElementById('centerYInput');

    const swirlSlider = document.getElementById('swirlSlider');
    const swirlValue = document.getElementById('swirlValue');
    const swirlInput = document.getElementById('swirlInput');

    const guidelineSelect = document.getElementById('guidelineSelect');
    const guidelineRotateBtn = document.getElementById('guidelineRotateBtn');

    // ====== Center offsets (before 2D rotate) ======
    let centerOffsetX = 0;
    let centerOffsetY = 0;

    // ====== Temps for sliders ======
    let isDragging = false;
    let lastTouchX = 0;
    let lastTouchY = 0;
    let lastPinchDistance = 0;
    let isPinching = false;
    let isMovingCenter = false;

    let tempScale = parseFloat(scaleSlider.value) || 1.5;
    let tempExponential = parseFloat(exponentialSlider.value) || 0;
    let tempPitch = parseFloat(pitchSlider.value) || 0;
    let tempRoll = parseFloat(rollSlider.value) || 0;
    let tempYaw = parseFloat(yawSlider.value) || 0;
    let tempImgRotate = parseFloat(imgRotateSlider.value) || 0;
    let tempSwirl = parseFloat(swirlSlider.value) || 0;

    // ====== Crop (Trim) state ======
    let cropEnabled = false;
    let cropAspect = 'free';
    let isCropDragging = false;
    let cropDragOffset = { x: 0, y: 0 };
    let cropRect = { x: 90, y: 90, w: 540, h: 540 };

    const cropToggleBtn = document.getElementById('cropToggleBtn');
    const cropModeValue = document.getElementById('cropModeValue');
    const cropAspectSelect = document.getElementById('cropAspectSelect');
    const cropSizeSlider = document.getElementById('cropSizeSlider');
    const cropSizeValue = document.getElementById('cropSizeValue');
    const cropDownloadBtn = document.getElementById('cropDownloadBtn');

    // ====== On load ======
    window.addEventListener('load', function () {
      loadSampleImage();
      loadGuidelineImages();

      guidelineSelect.addEventListener('change', function () {
        guidelineRotation = 0;
        render();
      });

      guidelineRotateBtn.addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        guidelineRotation = (guidelineRotation + 45) % 360;
        render();
      });

      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      if (!isTouchDevice) {
        document.getElementById('centerXGroup').style.display = 'block';
        document.getElementById('centerYGroup').style.display = 'block';
      }
    });

    // ====== Utility ======
    function showLoading(text) {
      const overlay = document.getElementById('loadingOverlay');
      const loadingText = document.getElementById('loadingText');
      loadingText.textContent = text;
      overlay.style.display = 'flex';
    }
    function hideLoading() {
      document.getElementById('loadingOverlay').style.display = 'none';
    }
    function isIOS() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent);
    }
    function normalizeAngle(angle, min, max) {
      const range = max - min;
      let n = angle % (range * 2);
      if (n > max) n -= range * 2;
      else if (n < min) n += range * 2;
      return Math.max(min, Math.min(max, n));
    }

    // ====== Sample / guidelines ======
    function loadSampleImage() {
      if (location.protocol === 'file:') return;
      const sampleImage = new Image();
      sampleImage.onload = function () {
        originalImage = sampleImage;
        createWorkingImages();
      };
      sampleImage.onerror = function () {
        console.log('sample4k.jpg is not available. select 360 image');
      };
      sampleImage.src = './sample4k.jpg';
    }
    function loadGuidelineImages() {
      if (location.protocol === 'file:') return;
      guidelineTypes.forEach((type) => {
        const img = new Image();
        img.onload = function () {
          guidelineImages[type] = img;
        };
        img.onerror = function () {
          console.log(`Guideline image not found: lines/${type}.png`);
        };
        img.src = `./lines/${type}.png`;
      });
    }

    function resetControlsAndSelectFile() {
      resetControls();
      fileInput.click();
    }

    // ====== Upload / DnD ======
    fileInput.addEventListener('change', handleFile);
    uploadArea.addEventListener('dragover', function (e) {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });
    uploadArea.addEventListener('dragleave', function () {
      uploadArea.classList.remove('dragover');
    });
    uploadArea.addEventListener('drop', function (e) {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        resetControls();
        processFile(files);
      }
    });

    function handleFile(e) {
      const file = e.target.files;
      if (file) processFile(file);
    }
    function processFile(file) {
      if (!file.type.startsWith('image/')) {
        alert('Choose image file!');
        return;
      }
      showLoading('Loading image...');
      const reader = new FileReader();
      reader.onload = function (e) {
        originalImage = new Image();
        originalImage.onload = function () {
          createWorkingImages();
        };
        originalImage.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function createWorkingImages() {
      if (!originalImage) return;
      showLoading('Creating working images...');
      setTimeout(function () {
        const workingCanvas = document.createElement('canvas');
        const workingCtx = workingCanvas.getContext('2d');
        workingCanvas.width = 1024;
        workingCanvas.height = 512;
        workingCtx.drawImage(originalImage, 0, 0, 1024, 512);

        workingImage = new Image();
        workingImage.onload = function () {
          const downloadCanvas = document.createElement('canvas');
          const downloadCtx = downloadCanvas.getContext('2d');
          downloadCanvas.width = 4096;
          downloadCanvas.height = 2048;
          downloadCtx.drawImage(originalImage, 0, 0, 4096, 2048);

          downloadImage = new Image();
          downloadImage.onload = function () {
            hideLoading();
            mainContent.style.display = 'block';
            render();
          };
          downloadImage.src = downloadCanvas.toDataURL();
        };
        workingImage.src = workingCanvas.toDataURL();
      }, 100);
    }

    // ====== Reset ======
    function resetControls() {
      scaleSlider.value = '1.5';
      exponentialSlider.value = '0';
      pitchSlider.value = '0';
      rollSlider.value = '0';
      yawSlider.value = '0';
      imgRotateSlider.value = '0';
      scaleValue.textContent = '1.50';
      exponentialValue.textContent = '0.00';
      pitchValue.textContent = '0.00¬∞';
      rollValue.textContent = '0.00¬∞';
      yawValue.textContent = '0.00¬∞';
      imgRotateValue.textContent = '0.00¬∞';

      tempScale = 1.5;
      tempExponential = 0;
      tempPitch = 0;
      tempRoll = 0;
      tempYaw = 0;
      tempImgRotate = 0;

      centerOffsetX = 0;
      centerOffsetY = 0;

      swirlSlider.value = '0';
      swirlValue.textContent = '0.00';
      swirlInput.value = '0.00';
      tempSwirl = 0;

      if (centerXSlider && centerYSlider) {
        centerXSlider.value = '0';
        centerYSlider.value = '0';
        centerXValue.textContent = '0.00';
        centerYValue.textContent = '0.00';
        centerXInput.value = '0.00';
        centerYInput.value = '0.00';
      }

      guidelineRotation = 0;
      guidelineRotateBtn.style.display = 'none';
      guidelineSelect.value = 'none';

      // ==== Crop reset ====
      setCropEnabled(false);
      cropAspect = 'free';
      cropAspectSelect.value = 'free';
      cropSizeSlider.value = '0.6';
      cropSizeValue.textContent = '0.60';
      cropRect = { x: 90, y: 90, w: 540, h: 540 };

      if (workingImage) render();
    }

    // ====== Slider events ======
    scaleSlider.addEventListener('input', function () {
      tempScale = parseFloat(scaleSlider.value);
      scaleValue.textContent = tempScale.toFixed(2);
      render();
    });
    exponentialSlider.addEventListener('input', function () {
      tempExponential = parseFloat(exponentialSlider.value);
      exponentialValue.textContent = tempExponential.toFixed(2);
      render();
    });
    swirlSlider.addEventListener('input', function () {
      tempSwirl = parseFloat(swirlSlider.value);
      swirlValue.textContent = tempSwirl.toFixed(2);
      render();
    });
    pitchSlider.addEventListener('input', function () {
      tempPitch = parseFloat(pitchSlider.value);
      pitchValue.textContent = tempPitch.toFixed(2) + '¬∞';
      render();
    });
    rollSlider.addEventListener('input', function () {
      tempRoll = parseFloat(rollSlider.value);
      rollValue.textContent = tempRoll.toFixed(2) + '¬∞';
      render();
    });
    yawSlider.addEventListener('input', function () {
      tempYaw = parseFloat(yawSlider.value);
      yawValue.textContent = tempYaw.toFixed(2) + '¬∞';
      render();
    });
    imgRotateSlider.addEventListener('input', function () {
      tempImgRotate = parseFloat(imgRotateSlider.value);
      imgRotateValue.textContent = tempImgRotate.toFixed(2) + '¬∞';
      render();
    });

    if (centerXSlider && centerYSlider) {
      centerXSlider.addEventListener('input', function () {
        centerOffsetX = -parseFloat(centerXSlider.value);
        centerXValue.textContent = parseFloat(centerXSlider.value).toFixed(2);
        render();
      });
      centerYSlider.addEventListener('input', function () {
        centerOffsetY = parseFloat(centerYSlider.value);
        centerYValue.textContent = centerOffsetY.toFixed(2);
        render();
      });
    }

    editModeSelect.addEventListener('change', function () {
      isLittlePlanet = editModeSelect.value === 'little_planet';
      render();
    });

    // Click to edit numeric
    function showInput(valueDisplay, input, slider, isDegree) {
      const current = isDegree
        ? valueDisplay.textContent.replace('¬∞', '')
        : valueDisplay.textContent;
      input.value = current;
      valueDisplay.style.display = 'none';
      input.style.display = 'inline-block';
      input.focus();
      input.select();
    }
    function hideInput(input, valueDisplay, slider, isDegree) {
      let newValue = parseFloat(input.value);
      if (isNaN(newValue)) {
        newValue = parseFloat(slider.value);
      } else {
        const min = parseFloat(slider.min);
        const max = parseFloat(slider.max);
        newValue = Math.max(min, Math.min(max, newValue));
        slider.value = newValue;
      }
      if (isDegree) {
        valueDisplay.textContent = newValue.toFixed(2) + '¬∞';
        if (slider === pitchSlider) tempPitch = newValue;
        else if (slider === rollSlider) tempRoll = newValue;
        else if (slider === yawSlider) tempYaw = newValue;
        else if (slider === imgRotateSlider) tempImgRotate = newValue;
      } else {
        valueDisplay.textContent = newValue.toFixed(2);
        if (slider === scaleSlider) tempScale = newValue;
        else if (slider === exponentialSlider) tempExponential = newValue;
        else if (slider === swirlSlider) tempSwirl = newValue;
      }
      input.style.display = 'none';
      valueDisplay.style.display = 'inline-block';
      render();
    }
    scaleValue.addEventListener('click', function () { showInput(scaleValue, scaleInput, scaleSlider, false); });
    exponentialValue.addEventListener('click', function () { showInput(exponentialValue, exponentialInput, exponentialSlider, false); });
    pitchValue.addEventListener('click', function () { showInput(pitchValue, pitchInput, pitchSlider, true); });
    rollValue.addEventListener('click', function () { showInput(rollValue, rollInput, rollSlider, true); });
    yawValue.addEventListener('click', function () { showInput(yawValue, yawInput, yawSlider, true); });
    imgRotateValue.addEventListener('click', function () { showInput(imgRotateValue, imgRotateInput, imgRotateSlider, true); });

    [scaleInput, exponentialInput, pitchInput, rollInput, yawInput, imgRotateInput, swirlInput].forEach(el => {
      el?.addEventListener('blur', function () {
        const map = new Map([
          [scaleInput, [scaleValue, scaleSlider, false]],
          [exponentialInput, [exponentialValue, exponentialSlider, false]],
          [pitchInput, [pitchValue, pitchSlider, true]],
          [rollInput, [rollValue, rollSlider, true]],
          [yawInput, [yawValue, yawSlider, true]],
          [imgRotateInput, [imgRotateValue, imgRotateSlider, true]],
          [swirlInput, [swirlValue, swirlSlider, false]],
        ]);
        const [v, s, d] = map.get(el);
        hideInput(el, v, s, d);
      });
      el?.addEventListener('keydown', function (e) {
        if (e.key === 'Enter') el.blur();
      });
    });

    // ====== Pointer helpers ======
    function isInActiveAreaMouse(event) {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const margin = 0.1;
      const left = rect.width * margin;
      const right = rect.width * (1 - margin);
      const top = rect.height * margin;
      const bottom = rect.height * (1 - margin);
      return x >= left && x <= right && y >= top && y <= bottom;
    }
    function isInActiveAreaTouch(touch) {
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      const margin = 0.1;
      const left = rect.width * margin;
      const right = rect.width * (1 - margin);
      const top = rect.height * margin;
      const bottom = rect.height * (1 - margin);
      return x >= left && x <= right && y >= top && y <= bottom;
    }

    // ====== Mouse / Touch handlers with Crop priority ======
    function getMouseCanvasPoint(e) {
      const rect = canvas.getBoundingClientRect();
      const sx = canvas.width / rect.width;
      const sy = canvas.height / rect.height;
      return { x: (e.clientX - rect.left) * sx, y: (e.clientY - rect.top) * sy };
    }
    function getTouchCanvasPoint(touch) {
      const rect = canvas.getBoundingClientRect();
      const sx = canvas.width / rect.width;
      const sy = canvas.height / rect.height;
      return { x: (touch.clientX - rect.left) * sx, y: (touch.clientY - rect.top) * sy };
    }

    canvas.addEventListener('mousedown', function (e) {
      // CropÂÑ™ÂÖà
      if (cropEnabled) {
        const p = getMouseCanvasPoint(e);
        isCropDragging = true;
        cropDragOffset.x = p.x - cropRect.x;
        cropDragOffset.y = p.y - cropRect.y;
        render();
        return;
      }

      if (!isInActiveAreaMouse(e)) return;
      isDragging = true;
      lastTouchX = e.clientX;
      lastTouchY = e.clientY;
      tempPitch = parseFloat(pitchSlider.value);
      tempRoll = parseFloat(rollSlider.value);
      tempYaw = parseFloat(yawSlider.value);
    });
    canvas.addEventListener('mousemove', function (e) {
      if (cropEnabled && isCropDragging) {
        const p = getMouseCanvasPoint(e);
        cropRect.x = p.x - cropDragOffset.x;
        cropRect.y = p.y - cropDragOffset.y;
        clampCropRect();
        render();
        return;
      }
      if (!isDragging) return;
      const dx = e.clientX - lastTouchX;
      const dy = e.clientY - lastTouchY;
      tempRoll -= dx * 0.5;
      tempPitch += dy * 0.5;
      tempYaw -= dx * 0.5;
      lastTouchX = e.clientX;
      lastTouchY = e.clientY;
      render();
    });
    canvas.addEventListener('mouseup', function () {
      if (cropEnabled) {
        isCropDragging = false;
        return;
      }
      if (isDragging) {
        tempPitch = normalizeAngle(tempPitch, -180, 180);
        tempRoll = normalizeAngle(tempRoll, -180, 180);
        tempYaw = normalizeAngle(tempYaw, -180, 180);
        pitchSlider.value = tempPitch;
        rollSlider.value = tempRoll;
        yawSlider.value = tempYaw;
        pitchValue.textContent = tempPitch.toFixed(2) + '¬∞';
        rollValue.textContent = tempRoll.toFixed(2) + '¬∞';
        yawValue.textContent = tempYaw.toFixed(2) + '¬∞';
        render();
      }
      isDragging = false;
    });
    canvas.addEventListener('mouseleave', function () {
      isDragging = false;
      isCropDragging = false;
    });

    canvas.addEventListener('touchstart', function (e) {
      e.preventDefault();
      if (cropEnabled && e.touches.length === 1) {
        const p = getTouchCanvasPoint(e.touches);
        isCropDragging = true;
        cropDragOffset.x = p.x - cropRect.x;
        cropDragOffset.y = p.y - cropRect.y;
        render();
        return;
      }

      if (!isInActiveAreaTouch(e.touches)) return;
      if (e.touches.length === 1) {
        isDragging = true;
        lastTouchX = e.touches.clientX;
        lastTouchY = e.touches.clientY;
        isPinching = false;
        isMovingCenter = false;
        tempPitch = parseFloat(pitchSlider.value);
        tempRoll = parseFloat(rollSlider.value);
        tempYaw = parseFloat(yawSlider.value);
      } else if (e.touches.length === 2) {
        isPinching = true;
        isDragging = false;
        isMovingCenter = false;
        const t1 = e.touches, t2 = e.touches[1];
        lastPinchDistance = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        tempScale = parseFloat(scaleSlider.value);
      } else if (e.touches.length === 3) {
        isMovingCenter = true;
        isDragging = false;
        isPinching = false;
        lastTouchX = e.touches.clientX;
        lastTouchY = e.touches.clientY;
        touchIndicator.style.display = 'block';
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', function (e) {
      e.preventDefault();
      if (cropEnabled && isCropDragging && e.touches.length === 1) {
        const p = getTouchCanvasPoint(e.touches);
        cropRect.x = p.x - cropDragOffset.x;
        cropRect.y = p.y - cropDragOffset.y;
        clampCropRect();
        render();
        return;
      }

      if (!isDragging && !isPinching && !isMovingCenter) return;
      if (isDragging && e.touches.length === 1) {
        const t = e.touches;
        const dx = t.clientX - lastTouchX;
        const dy = t.clientY - lastTouchY;
        tempRoll -= dx * 0.5;
        tempPitch += dy * 0.5;
        tempYaw -= dx * 0.5;
        lastTouchX = t.clientX;
        lastTouchY = t.clientY;
        render();
      } else if (isPinching && e.touches.length === 2) {
        const t1 = e.touches, t2 = e.touches[1];
        const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        const scaleChange = (dist - lastPinchDistance) * 0.01;
        tempScale = Math.max(0.1, Math.min(3.9, tempScale + scaleChange));
        lastPinchDistance = dist;
        render();
      } else if (isMovingCenter && e.touches.length === 3) {
        const t = e.touches;
        const dx = t.clientX - lastTouchX;
        const dy = t.clientY - lastTouchY;
        centerOffsetX += dx * 0.005;
        centerOffsetY += dy * 0.005;
        centerOffsetX = Math.max(-1, Math.min(1, centerOffsetX));
        centerOffsetY = Math.max(-1, Math.min(1, centerOffsetY));
        lastTouchX = t.clientX;
        lastTouchY = t.clientY;
        render();
      }
    }, { passive: false });

    canvas.addEventListener('touchend', function (e) {
      e.preventDefault();
      if (cropEnabled) {
        isCropDragging = false;
        return;
      }
      if (isDragging) {
        tempPitch = normalizeAngle(tempPitch, -180, 180);
        tempRoll = normalizeAngle(tempRoll, -180, 180);
        tempYaw = normalizeAngle(tempYaw, -180, 180);
        pitchSlider.value = tempPitch;
        rollSlider.value = tempRoll;
        yawSlider.value = tempYaw;
        pitchValue.textContent = tempPitch.toFixed(2) + '¬∞';
        rollValue.textContent = tempRoll.toFixed(2) + '¬∞';
        yawValue.textContent = tempYaw.toFixed(2) + '¬∞';
        render();
      } else if (isPinching) {
        scaleSlider.value = tempScale;
        scaleValue.textContent = tempScale.toFixed(2);
        render();
      } else if (isMovingCenter) {
        touchIndicator.style.display = 'none';
      }
      isDragging = false;
      isPinching = false;
      isMovingCenter = false;
    }, { passive: false });

    // ====== Math ======
    function sphericalToCartesian(theta, phi) {
      const x = Math.cos(phi) * Math.cos(theta);
      const y = Math.cos(phi) * Math.sin(theta);
      const z = Math.sin(phi);
      return [x, y, z];
    }
    function cartesianToSpherical(x, y, z) {
      const theta = Math.atan2(y, x);
      const phi = Math.asin(Math.max(-1, Math.min(1, z)));
      return [theta, phi];
    }
    function rotatePoint(x, y, z, pitch, roll, yaw) {
      const cp = Math.cos(pitch), sp = Math.sin(pitch);
      const cr = Math.cos(roll),  sr = Math.sin(roll);
      const cy = Math.cos(yaw),   sy = Math.sin(yaw);
      const rx = x * (cy * cr - sy * sp * sr) + y * (-sy * cp) + z * (cy * sr + sy * sp * cr);
      const ry = x * (sy * cr + cy * sp * sr) + y * (cy * cp) + z * (sy * sr - cy * sp * cr);
      const rz = x * (-cp * sr) + y * sp + z * (cp * cr);
      return [rx, ry, rz];
    }

    // ====== Render ======
    function render() {
      if (!workingImage) return;
      const scale = tempScale;
      const exponential = tempExponential;
      let pitch = (tempPitch * Math.PI) / 180;
      const roll = (tempRoll * Math.PI) / 180;
      const yaw = (tempYaw * Math.PI) / 180;
      const imgRot = (tempImgRotate * Math.PI) / 180;

      if (!isLittlePlanet) pitch += Math.PI;

      const size = 720;
      canvas.width = size;
      canvas.height = size;

      renderAtSize(size, scale, exponential, pitch, roll, yaw, imgRot, workingImage);
      drawGuideline();
      if (cropEnabled) drawCropOverlay();
    }

    function drawGuideline() {
      const selectedType = guidelineSelect.value;
      if (selectedType === 'none' || !guidelineImages[selectedType]) {
        guidelineRotateBtn.style.display = 'none';
        return;
      }
      guidelineRotateBtn.style.display = 'block';
      const gl = guidelineImages[selectedType];

      ctx.save();
      ctx.globalAlpha = 0.6;
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate((guidelineRotation * Math.PI) / 180);
      ctx.translate(-canvas.width / 2, -canvas.height / 2);
      ctx.drawImage(gl, 0, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    function applySwirlEffect(nx, ny, swirlStrength) {
      if (Math.abs(swirlStrength) < 0.01) return { x: nx, y: ny };
      const r = Math.sqrt(nx * nx + ny * ny);
      const innerRadius = 0.1;
      let effectStrength = 0;
      if (r > innerRadius) {
        const nd = (r - innerRadius) / (1.0 - innerRadius);
        effectStrength = nd * nd * swirlStrength;
      }
      const currentAngle = Math.atan2(ny, nx);
      const swirlAngle = effectStrength * Math.PI;
      const newAngle = currentAngle + swirlAngle;
      return { x: r * Math.cos(newAngle), y: r * Math.sin(newAngle) };
    }

    function renderAtSize(size, scale, exponential, pitch, roll, yaw, imgRot, sourceImage) {
      const imageData = ctx.createImageData(size, size);
      const data = imageData.data;

      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = sourceImage.width;
      tempCanvas.height = sourceImage.height;
      tempCtx.drawImage(sourceImage, 0, 0);
      const sourceData = tempCtx.getImageData(0, 0, sourceImage.width, sourceImage.height);

      const cosA = Math.cos(imgRot);
      const sinA = Math.sin(imgRot);
      const swirlStrength = tempSwirl;

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const nx0 = (x / (size - 1)) * 2 - 1;
          const ny0 = (y / (size - 1)) * 2 - 1;

          // 1) 2DÈÄÜÂõûËª¢
          const rx = nx0 * cosA + ny0 * sinA;
          const ry = -nx0 * sinA + ny0 * cosA;

          // 2) XY„Ç∑„Éï„ÉàÈÄÜ
          const nx1 = rx - centerOffsetX;
          const ny1 = ry - centerOffsetY;

          // 3) Ê∏¶Â∑ª„ÅçÈÄÜÂ§âÊèõ
          const s = applySwirlEffect(nx1, ny1, -swirlStrength);
          const nx = s.x;
          const ny = s.y;

          // 4) ÁêÉÈù¢Âá¶ÁêÜ
          const r = Math.sqrt(nx * nx + ny * ny);
          const angle = Math.atan2(ny, nx);
          let mappedR;
          if (exponential === 0) {
            mappedR = 2 * Math.atan(r * (4 - scale));
          } else {
            const atanComponent = 2 * Math.atan(r * (4 - scale));
            const expComponent = Math.pow(r, 1 + exponential * 0.5) * Math.PI;
            const blendFactor = Math.min(exponential / 3.0, 1.0);
            mappedR = (1 - blendFactor) * atanComponent + blendFactor * expComponent;
          }

          const phi = Math.PI / 2 - mappedR;
          const theta = angle;
          const cartesian = sphericalToCartesian(theta, phi);
          const rotated = rotatePoint(cartesian, cartesian[1], cartesian[2], pitch, roll, yaw);
          const spherical = cartesianToSpherical(rotated, rotated[1], rotated[2]);

          const u = (spherical + Math.PI) / (2 * Math.PI);
          const v = (spherical[1] + Math.PI / 2) / Math.PI;
          const imgX = Math.floor(u * sourceImage.width) % sourceImage.width;
          const imgY = Math.floor(v * sourceImage.height) % sourceImage.height;

          if (imgX >= 0 && imgX < sourceImage.width && imgY >= 0 && imgY < sourceImage.height) {
            const si = (imgY * sourceImage.width + imgX) * 4;
            const ti = (y * size + x) * 4;
            data[ti] = sourceData.data[si];
            data[ti + 1] = sourceData.data[si + 1];
            data[ti + 2] = sourceData.data[si + 2];
            data[ti + 3] = 255;
          }
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }

    // ====== Download original pipeline ======
    function processImageInChunks(canvas2, ctx2, outputSize, scale, exponential, pitch, roll, yaw, imgRot, chunkSize, currentY, callback) {
      const endY = Math.min(currentY + chunkSize, outputSize);
      const progress = Math.round((currentY / outputSize) * 100);
      document.getElementById('downloadBtn').textContent = 'üîÑ ' + progress + '%';

      if (!processImageInChunks.sourceData) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = downloadImage.width;
        tempCanvas.height = downloadImage.height;
        tempCtx.drawImage(downloadImage, 0, 0);
        processImageInChunks.sourceData = tempCtx.getImageData(0, 0, downloadImage.width, downloadImage.height);
      }

      const sourceData = processImageInChunks.sourceData;
      const chunkHeight = endY - currentY;
      const imageData = ctx2.createImageData(outputSize, chunkHeight);
      const data = imageData.data;

      const cosA = Math.cos(imgRot);
      const sinA = Math.sin(imgRot);
      const swirlStrength = tempSwirl;

      for (let y = 0; y < chunkHeight; y++) {
        for (let x = 0; x < outputSize; x++) {
          const actualY = currentY + y;
          const nx0 = (x / (outputSize - 1)) * 2 - 1;
          const ny0 = (actualY / (outputSize - 1)) * 2 - 1;

          const rx = nx0 * cosA + ny0 * sinA;
          const ry = -nx0 * sinA + ny0 * cosA;

          const nx1 = rx - centerOffsetX;
          const ny1 = ry - centerOffsetY;

          const s = applySwirlEffect(nx1, ny1, -swirlStrength);
          const nx = s.x;
          const ny = s.y;

          const r = Math.sqrt(nx * nx + ny * ny);
          const angle = Math.atan2(ny, nx);

          let mappedR;
          if (exponential === 0) {
            mappedR = 2 * Math.atan(r * (4 - scale));
          } else {
            const atanComponent = 2 * Math.atan(r * (4 - scale));
            const expComponent = Math.pow(r, 1 + exponential * 0.5) * Math.PI;
            const blendFactor = Math.min(exponential / 3.0, 1.0);
            mappedR = (1 - blendFactor) * atanComponent + blendFactor * expComponent;
          }

          const phi = Math.PI / 2 - mappedR;
          const theta = angle;
          const cartesian = sphericalToCartesian(theta, phi);
          const rotated = rotatePoint(cartesian, cartesian[1], cartesian[2], pitch, roll, yaw);
          const spherical = cartesianToSpherical(rotated, rotated[1], rotated[2]);

          const u = (spherical + Math.PI) / (2 * Math.PI);
          const v = (spherical[1] + Math.PI / 2) / Math.PI;

          const imgX = Math.floor(u * downloadImage.width) % downloadImage.width;
          const imgY = Math.floor(v * downloadImage.height) % downloadImage.height;

          if (imgX >= 0 && imgX < downloadImage.width && imgY >= 0 && imgY < downloadImage.height) {
            const si = (imgY * downloadImage.width + imgX) * 4;
            const ti = (y * outputSize + x) * 4;
            data[ti] = sourceData.data[si];
            data[ti + 1] = sourceData.data[si + 1];
            data[ti + 2] = sourceData.data[si + 2];
            data[ti + 3] = 255;
          }
        }
      }

      ctx2.putImageData(imageData, 0, currentY);

      if (endY < outputSize) {
        setTimeout(function () {
          processImageInChunks(canvas2, ctx2, outputSize, scale, exponential, pitch, roll, yaw, imgRot, chunkSize, endY, callback);
        }, 10);
      } else {
        delete processImageInChunks.sourceData;
        callback();
      }
    }

    document.getElementById('downloadBtn').addEventListener('click', function () {
      if (!downloadImage) return;

      const outputSize = parseInt(resolutionSelect.value);
      const outputFormat = formatSelect.value;
      const scale = parseFloat(scaleSlider.value);
      const exponential = parseFloat(exponentialSlider.value);
      let pitch = (parseFloat(pitchSlider.value) * Math.PI) / 180;
      const roll = (parseFloat(rollSlider.value) * Math.PI) / 180;
      const yaw = (parseFloat(yawSlider.value) * Math.PI) / 180;
      const imgRot = (parseFloat(imgRotateSlider.value) * Math.PI) / 180;

      if (!isLittlePlanet) pitch += Math.PI;

      const deviceMemory = navigator.deviceMemory || 2;
      if (outputSize >= 4096 && deviceMemory < 4) {
        if (!confirm('È´òËß£ÂÉèÂ∫¶Âá∫Âäõ„ÅØÂ§ßÈáè„ÅÆ„É°„É¢„É™„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇÁ∂öË°å„Åó„Åæ„Åô„ÅãÔºü')) return;
      }

      const downloadBtn = document.getElementById('downloadBtn');
      const originalText = downloadBtn.textContent;
      downloadBtn.textContent = 'üîÑ Processing...';
      downloadBtn.disabled = true;

      let newWindow = null;
      if (isIOS()) {
        newWindow = window.open('about:blank', '_blank');
        if (!newWindow) {
          alert('„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Åå„Éñ„É≠„ÉÉ„ÇØ„Åï„Çå„Åæ„Åó„Åü„ÄÇ');
          downloadBtn.textContent = originalText;
          downloadBtn.disabled = false;
          return;
        }
        const countdownTime = outputSize >= 4096 ? 30 : 15;
        newWindow.document.write('<!DOCTYPE html><html><head><title>processing</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><style>body{margin:0;padding:20px;background:linear-gradient(135deg,#1e3c72,#2a5298);display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;font-family:-apple-system,BlinkMacSystemFont,sans-serif;color:#fff}.spinner{width:60px;height:60px;border:4px solid rgba(255,255,255,.3);border-top:4px solid #fff;border-radius:50%;animation:spin 1s linear infinite;margin:20px 0}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}</style></head><body><div class="spinner"></div><div id="status">Processing... '+countdownTime+'</div></body></html>');
        let c = countdownTime;
        const st = newWindow.document.getElementById('status');
        const timer = setInterval(()=>{ if (!st) return clearInterval(timer); c--; st.textContent='Processing... '+(c>0?c:''); if (c<=0) clearInterval(timer);},1000);
      }

      setTimeout(function () {
        try {
          const downloadCanvas = document.createElement('canvas');
          const downloadCtx = downloadCanvas.getContext('2d');
          downloadCanvas.width = outputSize;
          downloadCanvas.height = outputSize;

          const chunkSize =
